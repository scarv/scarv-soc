
VERILATOR   = $(VERILATOR_ROOT)/bin/verilator

VL_DIR      = $(SOC_WORK)/verilator

VL_WAVES    = $(VL_DIR)/waves.vcd
VL_TIMEOUT  = 10000
VL_ARGS     = 

VL_FLAGS    = --cc -CFLAGS "-O2" -O3 -CFLAGS -g\
               --exe --trace \
               $(VL_BUILD_FLAGS)

VL_SOC_CMD  = $(SOC_HOME)/flow/verilator/scarv-soc-tb.cmd

#
# 1. Build dir
# 2. Top module name
define map_vl_makefile
${1}/V${2}.mk
endef

#
# 1. Build dir
# 2. Top module name
define map_vl_exe
${1}/${2}
endef

#
# Add a new verilator build
#
# 1 - Output verilated executable
# 2 - verilator working directory.
# 3 - ROM memory file
# 4 - RAM memory file
#
define tgt_verilator_build

$(call map_vl_makefile,${2},${1}) :
	@mkdir -p ${2}
	$(VERILATOR) $(VL_FLAGS)  --Mdir ${2} -o $(call map_vl_exe,${2},${1}) \
        -GCCX_ROM_INIT_FILE="\"$(strip ${3})\""     \
        -GCCX_RAM_INIT_FILE="\"$(strip ${4})\""     \
        -DSCARV_SOC_VERILATOR                       \
        -f $(VL_SOC_CMD)
	$(MAKE) -C ${2} -f Vscarv_soc.mk

verilator-build-${1}: $(call map_vl_makefile,${2},${1})
	$(MAKE) -C ${2} -f Vscarv_soc.mk

endef

$(eval $(call tgt_verilator_build,scarv-soc,$(VL_DIR),rom.hex,ram.hex))

VL_SCARV_SOC=$(call map_vl_exe,$(VL_DIR),scarv-soc)

verilator-run-waves: $(VL_SCARV_SOC) $(FSBL_HEX)
	cp $(FSBL_HEX) $(dir $(VL_SCARV_SOC))/rom.hex
	touch          $(dir $(VL_SCARV_SOC))/ram.hex
	cd $(dir $(VL_SCARV_SOC)) && $(VL_SCARV_SOC) $(VL_ARGS) \
        +WAVES=$(VL_WAVES) \
        +TIMEOUT=$(VL_TIMEOUT)

verilator-clean:
	rm -rf $(VL_DIR)

